
#include <iostream>
#include <queue>
#include <cmath>
#include <algorithm>

#include "fastm_common.h"





///-----------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif


extern __declspec(dllexport) int fast_marching_3d(
    unsigned int size[3], float const *speed, 
    unsigned int npoints, unsigned int const *points,
    float *distance, int *labels, 
    unsigned int heap_size=1000,
    float offset=0.,
    bool debug=false)
    
{
    unsigned int ni = size[0];
    unsigned int nj = size[1];
    unsigned int nk = size[2];
    
    // std::cout << "image size: " << ni << " " << nj << " " << nk << "\n";
    
    float s, min_speed = 1e10;
    
    /// neighborhood
    unsigned int neigh_size = 6;
    int neigh[6][3] = {{-1,0,0},{1,0,0},{0,-1,0},{0,1,0},{0,0,-1},{0,0,1}};
    
    /// allocate maps ?
    //Q = new int[ni*nj*nk]; // label map (-2: unknown,-1:narrow band)
    //D = new float[ni*nj*nk];        // distance map
    int   *Q = labels; // label map (-2: unknown,-1:narrow band)
    float *D = distance;
    
    for (int iq = ni*nj*nk - 1; iq >= 0; iq--) 
    {
        Q[iq] = -2;
        D[iq] = 1e10;
        
        /// compute min speed
        s = speed[iq];
        if (s<min_speed) min_speed = s;
    }
    
    /// Distance function class
    // std::cout << "instanciate distance function\n";
    Distance distance_function(size,speed,Q,D,offset);
    
    /// heap
    unsigned int top = 0;
    std::queue<Cell> *H = new std::queue<Cell>[heap_size+1];
    for (unsigned int ip=0; ip<npoints; ++ip)
    {
        unsigned int i = points[ip*3];
        unsigned int j = points[ip*3+1];
        unsigned int k = points[ip*3+2];
        
        SET(D,i,j,k,0.0);
        SET(Q,i,j,k,-1);
        
        Cell c( GET(Q,i,j,k), GET(D,i,j,k), ip, i,j,k );
        H[top].push(c); /// push cell (copy) at the end of the top queue
        
        // std::cout 
            // << "heap top: " << H[top].back().i << " " 
                            // << H[top].back().j << " "
                            // << H[top].back().k << ", "
                            // << "q = " << H[top].back().q << ", "
                            // << "label = " << H[top].back().label << ", "
                            // << "d = " << H[top].back().d << "\n";
    }
    
    
    float delta = 1/((min_speed+offset)*heap_size);
    // std::cout << "min speed: " << min_speed << "\n";
    // std::cout << "delta: " << delta << "\n";
    
    /// loop: while heap not empty
    unsigned int n_empty = 0;
    unsigned int iiter = 0;
    // std::cout << "start loop\n";
    while (1)
    {
        // std::cout << "iteration: " << iiter++ << " (top=" << top << ")\n";
    
        if (H[top].empty())
        {
            // std::cout << "\t H top empty (count: " << n_empty << ")\n";
            
            n_empty +=1;
            top = (top+1)%(heap_size+1);
            
            /// stop condition: all queues are empty
            if (n_empty == heap_size+1) break;
            else continue;
        }
        n_empty = 0;
        
        /// extract front cell from top queue
        Cell const &c = H[top].front();
        H[top].pop();
        // std::cout 
            // << "\t front cell: " << c.i << " " 
                                 // << c.j << " " 
                                 // << c.k << ", "
                                 // << "q = " << c.q << ", "
                                 // << "label = " << c.label << ", "
                                 // << "d = " << c.d << "\n";
        
        /// skip if already frozen
        if (c.q >= 0) continue;
        
        
        /// freeze c
        c.q = c.label;
        
        // std::cout 
            // << "\t set label" << c.label << ": " << GET(Q,c.i,c.j,c.k) << "\n";
        
        
        /// for each neighbor of v
        // std::cout << "\t compute neighborhood distances\n";
        for (unsigned int in=0; in<neigh_size; ++in)
        {
            int i = c.i + neigh[in][0];
            int j = c.j + neigh[in][1];
            int k = c.k + neigh[in][2];
            
            if ((i<0) || (i>=(int)ni) || 
                (j<0) || (j>=(int)nj) || 
                (k<0) || (k>=(int)nk) )
                continue;
            
            /// get state of neighbor
            int state = GET(Q, i, j, k);
            
            // std::cout 
                // << "\t\t neighbor: " << i << " " << j << " " << k << ", "
                // << "q = " << state << "\n";
        
            /// if not frozen
            if (state < 0)
            {
                /// get speed
                float speed_ = GET(speed,i,j,k);
            
                /// compute distance
                float dist = distance_function(
                    (unsigned int)i,
                    (unsigned int)j,
                    (unsigned int)k);

    
                /// save distance if shorter
                float & d = GET(D,i,j,k);
                if ((state==-1) && (dist > d)) continue;
                /// mark as narrow band
                else if (state == -2) SET(Q, i, j, k, -1);
                
                SET(D,i,j,k,dist);
                
                // std::cout 
                    // << "\t\t speed = " << speed_ << ", "
                    // << "distance = " << dist << "\n";
                
                /// mark as narrow band
                SET(Q, i, j, k, -1);
                
                // std::cout << "qs ...\n";
                // for (int iq = 0; iq <ni*nj*nk; iq++) 
                    // std::cout << Q[iq] << " ";
                // std::cout << "\n";
                
                /// add to the heap
                int h_index = int(dist/delta)%(heap_size+1);
                Cell c(GET(Q,i,j,k), GET(D,i,j,k), c.label, i,j,k);
                H[h_index].push(c);
                
                // std::cout << "\t\t heap index: " << h_index <<"\n";
                
            } /// end if (state not frozen)
            
        } /// end for (each neighbor)
        // std::cout << "\t end neighborhood loop\n";
        
    } /// end while (heap not empty)
    // std::cout << "end loop\n";
    
    return 0;
    
} /// end fast_marching_3d()
///-----------------------------------------------------------------------------

///-----------------------------------------------------------------------------
extern __declspec(dllexport) int fast_marching_distance_3d(
    unsigned int size[3], float const *speed, 
    unsigned int npoints, unsigned int const *points,
    float *DM, int *labels, 
    unsigned int heap_size=1000,
    float offset=0.,
    bool integral_distance=false,
    bool debug=false)
    
{
    unsigned int ni = size[0];
    unsigned int nj = size[1];
    unsigned int nk = size[2];
        
    float s, min_speed = 1e10;
    
    /// neighborhood
    unsigned int neigh_size = 6;
    int neigh[6][3] = {{-1,0,0},{1,0,0},{0,-1,0},{0,1,0},{0,0,-1},{0,0,1}};

    // init distance matrix
    unsigned int *nDM = new unsigned int[npoints*npoints];
    for (unsigned int id=0; id < npoints*npoints; ++id)
    {
        DM[id] = 1e10;
        nDM[id] = 0;
    }
    
    /// init labels and distance
    int   *Q = labels;
    float *D = new float[ni*nj*nk];
    for (int iq = ni*nj*nk - 1; iq >= 0; iq--) 
    {
        Q[iq] = -2;
        D[iq] = 1e10;
        
        /// compute min speed
        s = speed[iq];
        if (s<min_speed) min_speed = s;
    }
    
    /// Distance function class
    Distance distance_function(size,speed,Q,D,offset);
    
    /// heap
    unsigned int top = 0;
    std::queue<Cell> *H = new std::queue<Cell>[heap_size+1];
    for (unsigned int ip=0; ip<npoints; ++ip)
    {
        unsigned int i = points[ip*3];
        unsigned int j = points[ip*3+1];
        unsigned int k = points[ip*3+2];
        
        SET(D,i,j,k,0.0);
        SET(Q,i,j,k,-1);
        
        Cell c( GET(Q,i,j,k), GET(D,i,j,k), ip, i,j,k );
        H[top].push(c); /// push cell (copy) at the end of the top queue
    }
    
    
    float delta = 1/((min_speed+offset)*heap_size);
    
    /// loop: while heap not empty
    unsigned int n_empty = 0;
    unsigned int iiter = 0;
    while (1)
    {
        if (H[top].empty())
        {
            n_empty +=1;
            top = (top+1)%(heap_size+1);
            
            /// stop condition: all queues are empty
            if (n_empty == heap_size+1) break;
            else continue;
        }
        n_empty = 0;
        
        /// extract front cell from top queue
        Cell const &c = H[top].front();
        H[top].pop();
        
        /// skip if already frozen
        if (c.q >= 0) continue;
        
        
        /// freeze c
        c.q = c.label;
        
        
        /// for each neighbor of v
        for (unsigned int in=0; in<neigh_size; ++in)
        {
            int i = c.i + neigh[in][0];
            int j = c.j + neigh[in][1];
            int k = c.k + neigh[in][2];
            
            if ((i<0) || (i>=(int)ni) || 
                (j<0) || (j>=(int)nj) || 
                (k<0) || (k>=(int)nk) )
                continue;
            
            /// get state of neighbor
            int state = GET(Q, i, j, k);
            
            /// if not frozen
            if (state < 0)
            {
                /// get speed
                float speed_ = GET(speed,i,j,k);
            
                /// compute distance
                float dist = distance_function(
                    (unsigned int)i,
                    (unsigned int)j,
                    (unsigned int)k);

    
                /// save distance if shorter
                float & d = GET(D,i,j,k);
                if ((state==-1) && (dist > d)) continue;
                /// mark as narrow band
                else if (state == -2) SET(Q, i, j, k, -1);
                
                SET(D,i,j,k,dist);
                
                /// mark as narrow band
                SET(Q, i, j, k, -1);
                
                /// add to the heap
                int h_index = int(dist/delta)%(heap_size+1);
                Cell c(GET(Q,i,j,k), GET(D,i,j,k), c.label, i,j,k);
                H[h_index].push(c);
                
            } /// end if (state not frozen)
            
            /// fill distance matrix
            else if (state != c.label)
            {
                unsigned int &n_path = nDM[state*npoints + c.label];
                
                /// shortest path and integral distance
                if ((n_path == 0) || integral_distance)
                {
                    // std::cout << state << " " << c.label << "\n";
                    DM[state*npoints + c.label] = c.d + GET(D,i,j,k);
                    DM[c.label*npoints + state] = c.d + GET(D,i,j,k);
                    n_path ++;
                    nDM[c.label*npoints + state]++;
                    
                    // std::cout
                        // << c.d + GET(D,i,j,k) << ", (" 
                        // << n_path << ")\n";
                }
            }
            
        } /// end for (each neighbor)
        
    } /// end while (heap not empty)
    
    if (integral_distance)
    {
        /// normalize distances
        for (unsigned int i=0; i < npoints*npoints; ++i)
        {
            if (nDM[i] > 0)
            {
                DM[i] /= nDM[i];
            }
        }
    }
    
    delete[] nDM;
    delete[] D;
    
    return 0;
    
} /// end fast_marching_3d()
///-----------------------------------------------------------------------------

///-----------------------------------------------------------------------------
extern __declspec(dllexport) int fast_marching_3d_aniso(
    unsigned int size[3], float const *image, 
    unsigned int npoints, unsigned int const *points,
    float *distance, int *labels, 
    unsigned int heap_size=1000,
    float offset=0.,
    bool debug=false)
    
{
    unsigned int ni = size[0];
    unsigned int nj = size[1];
    unsigned int nk = size[2];
    
    /// neighborhood
    unsigned int neigh_size = 6;
    int neigh[6][3] = {{-1,0,0},{1,0,0},{0,-1,0},{0,1,0},{0,0,-1},{0,0,1}};
    
    int   *Q = labels; // label map (-2: unknown,-1:narrow band)
    float *D = distance;
    
    for (int iq = ni*nj*nk - 1; iq >= 0; iq--) Q[iq] = -2;
    
    /// compute minimum gap (gradient)
    float min_gap = 1e10;
    for (int i=0; i < (int)ni; i++)
    for (int j=0; j < (int)nj; j++)
    for (int k=0; k < (int)nk; k++)
    {
        float gx = 1e10, gy = 1e10, gz = 1e10;
        /// compute min speed
        if (i < (int)ni-1)
            gx = std::abs(GET(image,i,j,k) - GET(image,i+1,j,k));
        if (j < (int)nj-1)
            gy = std::abs(GET(image,i,j,k) - GET(image,i,j+1,k));
        if (k < (int)nk-1)
            gz = std::abs(GET(image,i,j,k) - GET(image,i,j,k+1));
            
        if (gx < min_gap) min_gap = gx;
        if (gy < min_gap) min_gap = gy;
        if (gz < min_gap) min_gap = gz;
    }
    
    /// Distance function class
    Distance_aniso distance_function(size,image,Q,D);
    
    /// heap
    unsigned int top = 0;
    std::queue<Cell> *H = new std::queue<Cell>[heap_size+1];
    for (unsigned int ip=0; ip<npoints; ++ip)
    {
        unsigned int i = points[ip*3];
        unsigned int j = points[ip*3+1];
        unsigned int k = points[ip*3+2];
        
        SET(D,i,j,k,0.0);
        SET(Q,i,j,k,-1);
        
        Cell c( GET(Q,i,j,k), GET(D,i,j,k), ip, i,j,k );
        H[top].push(c); /// push cell (copy) at the end of the top queue
    }
    
    
    float delta = 1/(min_gap*heap_size);
    
    /// loop: while heap not empty
    unsigned int n_empty = 0;
    unsigned int iiter = 0;
    while (1)
    {
    
        if (H[top].empty())
        {
            n_empty +=1;
            top = (top+1)%(heap_size+1);
            
            /// stop condition: all queues are empty
            if (n_empty == heap_size+1) break;
            else continue;
        }
        n_empty = 0;
        
        /// extract front cell from top queue
        Cell const &c = H[top].front();
        H[top].pop();
        
        /// skip if already frozen
        if (c.q >= 0) continue;
        
        
        /// freeze c
        c.q = c.label;
        
        /// for each neighbor of v
        for (unsigned int in=0; in<neigh_size; ++in)
        {
            int i = c.i + neigh[in][0];
            int j = c.j + neigh[in][1];
            int k = c.k + neigh[in][2];
            
            if ((i<0) || (i>=(int)ni) || 
                (j<0) || (j>=(int)nj) || 
                (k<0) || (k>=(int)nk) )
                continue;
            
            /// get state of neighbor
            int state = GET(Q, i, j, k);
        
            /// if not frozen
            if (state < 0)
            {
                /// compute distance
                float dist = distance_function(
                    (unsigned int)i,
                    (unsigned int)j,
                    (unsigned int)k);
  
                /// save distance if shorter
                float & d = GET(D,i,j,k);
                if ((state==-1) && (dist > d)) continue;
                /// mark as narrow band
                else if (state == -2) SET(Q, i, j, k, -1);
                
                d = dist;
                
                /// add to the heap
                int h_index = int(dist/delta)%(heap_size+1);
                Cell c(GET(Q,i,j,k), GET(D,i,j,k), c.label, i,j,k);
                H[h_index].push(c);
                
            } /// end if (state not frozen)

            
        } /// end for (each neighbor)
        
    } /// end while (heap not empty)
    
    return 0;
    
} /// end fast_marching_3d()

#ifdef __cplusplus
}
#endif
    